/*
 * This program source code file is part of KiCad, a free EDA CAD application.
 *
 * Copyright (C) 2009 SoftPLC Corporation, Dick Hollenbeck <dick@softplc.com>
 * Copyright (C) 2009 Jean-Pierre Charras, jean-pierre.charras@inpg.fr
 * Copyright (C) 2009 KiCad Developers, see change_log.txt for contributors.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you may find one here:
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * or you may search the http://www.gnu.org website for the version 2 license,
 * or you may write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include <fctsys.h>
#include <common.h>
#include <kicad_string.h>
#include <pcbnew.h>
#include <richio.h>
#include <macros.h>

#include <class_board.h>
#include <class_netclass.h>


// This will get mapped to "kicad_default" in the specctra_export.
const char NETCLASS::Default[] = "Default";

// Initial values for netclass initialization
const int NETCLASS::DEFAULT_CLEARANCE  = Millimeter2iu( 0.2 ); // track to track and track to pads clearance
const int NETCLASS::DEFAULT_VIA_DIAMETER  = Millimeter2iu( 0.8 );
const int NETCLASS::DEFAULT_VIA_DRILL  = Millimeter2iu( 0.4 );
const int NETCLASS::DEFAULT_UVIA_DIAMETER = Millimeter2iu( 0.3 );
const int NETCLASS::DEFAULT_UVIA_DRILL = Millimeter2iu( 0.1 );
const int NETCLASS::DEFAULT_TRACK_WIDTH = Millimeter2iu( 0.25 );
const int NETCLASS::DEFAULT_DIFF_PAIR_WIDTH = Millimeter2iu( 0.2 );
const int NETCLASS::DEFAULT_DIFF_PAIR_GAP = Millimeter2iu( 0.25 );
const int NETCLASS::DEFAULT_MAX_VIAS = 0; // unlimited if zero
const int NETCLASS::DEFAULT_TOPOLOGY = 0; // any if zero
const int NETCLASS::DEFAULT_MIN_LENGTH = 0; // none if zero
const int NETCLASS::DEFAULT_MAX_LENGTH = 0; // none if zero
const int NETCLASS::DEFAULT_MAX_SKEW = 0; // none if zero
const int NETCLASS::DEFAULT_STUB_LENGTH = 0; // none if zero
const int NETCLASS::DEFAULT_TYPE = 0; // none if zero
const unsigned NETCLASS::DEFAULT_LAYER = UINT_MAX; // all layers

NETCLASS::NETCLASS( const wxString& aName ) :
    m_Name( aName )
{
    // Default settings
    SetClearance( DEFAULT_CLEARANCE );
    SetViaDrill( DEFAULT_VIA_DRILL );
    SetuViaDrill( DEFAULT_UVIA_DRILL );
    // These defaults will be overwritten by SetParams,
    // from the board design parameters, later
    SetTrackWidth( DEFAULT_TRACK_WIDTH );
    SetViaDiameter( DEFAULT_VIA_DIAMETER );
    SetuViaDiameter( DEFAULT_UVIA_DIAMETER );
    SetDiffPairGap( DEFAULT_DIFF_PAIR_GAP );
    SetDiffPairWidth( DEFAULT_DIFF_PAIR_WIDTH );
    SetMaxVias( DEFAULT_MAX_VIAS );
    SetTopology( DEFAULT_TOPOLOGY );
    SetMinLength( DEFAULT_MIN_LENGTH );
    SetMaxLength( DEFAULT_MAX_LENGTH );
    SetMaxSkew( DEFAULT_MAX_SKEW );
    SetStubLength( DEFAULT_STUB_LENGTH );
    SetType( DEFAULT_TYPE );
    SetLayer( DEFAULT_LAYER );
}


void NETCLASS::SetParams( const NETCLASS& aDefaults )
{
    SetClearance( aDefaults.GetClearance() );
    SetTrackWidth( aDefaults.GetTrackWidth() );
    SetViaDiameter( aDefaults.GetViaDiameter() );
    SetViaDrill( aDefaults.GetViaDrill() );
    SetuViaDiameter( aDefaults.GetuViaDiameter() );
    SetuViaDrill( aDefaults.GetuViaDrill() );
    SetDiffPairWidth( aDefaults.GetDiffPairWidth() );
    SetDiffPairGap( aDefaults.GetDiffPairGap() );
    SetMaxVias( aDefaults.GetMaxVias() );
    SetTopology( aDefaults.GetTopology() );
    SetMinLength( aDefaults.GetMinLength() );
    SetMaxLength( aDefaults.GetMaxLength() );
    SetMaxSkew( aDefaults.GetMaxSkew() );
    SetStubLength( aDefaults.GetStubLength() );
    SetType( aDefaults.GetType() );
    SetLayer( aDefaults.GetLayer() );
}


NETCLASS::~NETCLASS()
{
}


NETCLASSES::NETCLASSES()
{
}


NETCLASSES::~NETCLASSES()
{
}


bool NETCLASSES::Add( NETCLASSPTR aNetClass )
{
    const wxString& name = aNetClass->GetName();

    if( name == NETCLASS::Default )
    {
        // invoke operator=(), which is currently generated by compiler.
        GetDefault() = aNetClass;

        return true;
    }

    // Test for an existing netclass:
    if( !Find( name ) )
    {
        // name not found, take ownership
        m_NetClasses[name] = aNetClass;

        return true;
    }
    else
    {
        // name already exists
        // do not "take ownership" and return false telling caller such.
        return false;
    }
}


NETCLASSPTR NETCLASSES::Remove( const wxString& aNetName )
{
    NETCLASS_MAP::iterator found = m_NetClasses.find( aNetName );

    if( found != m_NetClasses.end() )
    {
        std::shared_ptr<NETCLASS> netclass = found->second;
        m_NetClasses.erase( found );
        return netclass;
    }

    return NETCLASSPTR();
}


NETCLASSPTR NETCLASSES::Find( const wxString& aName ) const
{
    if( aName == NETCLASS::Default )
        return GetDefault();

    NETCLASS_MAP::const_iterator found = m_NetClasses.find( aName );

    if( found == m_NetClasses.end() )
        return NETCLASSPTR();
    else
        return found->second;
}


void BOARD::SynchronizeNetsAndNetClasses()
{
    NETCLASSES& netClasses = m_designSettings.m_NetClasses;
    NETCLASSPTR defaultNetClass = netClasses.GetDefault();

    // set all NETs to the default NETCLASS, then later override some
    // as we go through the NETCLASSes.

    for( NETINFO_LIST::iterator net( m_NetInfo.begin() ), netEnd( m_NetInfo.end() );
                net != netEnd; ++net )
    {
        net->SetClass( defaultNetClass );
    }

    // Add netclass name and pointer to nets.  If a net is in more than one netclass,
    // set the net's name and pointer to only the first netclass.  Subsequent
    // and therefore bogus netclass memberships will be deleted in logic below this loop.
    for( NETCLASSES::iterator clazz = netClasses.begin(); clazz != netClasses.end(); ++clazz )
    {
        NETCLASSPTR netclass = clazz->second;

        for( NETCLASS::const_iterator member = netclass->begin(); member != netclass->end(); ++member )
        {
            const wxString& netname = *member;

            // although this overall function seems to be adequately fast,
            // FindNet( wxString ) uses now a fast binary search and is fast
            // event for large net lists
            NETINFO_ITEM* net = FindNet( netname );

            if( net && net->GetClassName() == NETCLASS::Default )
            {
                net->SetClass( netclass );
            }
        }
    }

    // Finally, make sure that every NET is in a NETCLASS, even if that
    // means the Default NETCLASS.  And make sure that all NETCLASSes do not
    // contain netnames that do not exist, by deleting all netnames from
    // every netclass and re-adding them.

    for( NETCLASSES::iterator clazz = netClasses.begin(); clazz != netClasses.end(); ++clazz )
    {
        NETCLASSPTR netclass = clazz->second;

        netclass->Clear();
    }

    defaultNetClass->Clear();

    for( NETINFO_LIST::iterator net( m_NetInfo.begin() ), netEnd( m_NetInfo.end() );
            net != netEnd; ++net )
    {
        const wxString& classname = net->GetClassName();

        // because of the std:map<> this should be fast, and because of
        // prior logic, netclass should not be NULL.
        NETCLASSPTR netclass = netClasses.Find( classname );

        wxASSERT( netclass );

        netclass->Add( net->GetNetname() );
    }

    // Set initial values for custom track width & via size to match the default netclass settings
    m_designSettings.UseCustomTrackViaSize( false );
    m_designSettings.SetCustomTrackWidth( defaultNetClass->GetTrackWidth() );
    m_designSettings.SetCustomViaSize( defaultNetClass->GetViaDiameter() );
    m_designSettings.SetCustomViaDrill( defaultNetClass->GetViaDrill() );
}


#if defined(DEBUG)

void NETCLASS::Show( int nestLevel, std::ostream& os ) const
{
    // for now, make it look like XML:
    //NestedSpace( nestLevel, os )

    os << '<' << GetClass().Lower().mb_str() << ">\n";

    for( const_iterator i = begin();  i!=end();  ++i )
    {
        // NestedSpace( nestLevel+1, os ) << *i;
        os << TO_UTF8( *i );
    }

    // NestedSpace( nestLevel, os )
    os << "</" << GetClass().Lower().mb_str() << ">\n";
}

#endif


void NETCLASS::Format( OUTPUTFORMATTER* aFormatter, int aNestLevel, int aControlBits ) const
{
    aFormatter->Print( aNestLevel, "(net_class %s %s\n",
                       aFormatter->Quotew( GetName() ).c_str(),
                       aFormatter->Quotew( GetDescription() ).c_str() );

    aFormatter->Print( aNestLevel+1, "(clearance %s)\n", FMT_IU( GetClearance() ).c_str() );
    aFormatter->Print( aNestLevel+1, "(trace_width %s)\n", FMT_IU( GetTrackWidth() ).c_str() );

    aFormatter->Print( aNestLevel+1, "(via_dia %s)\n", FMT_IU( GetViaDiameter() ).c_str() );
    aFormatter->Print( aNestLevel+1, "(via_drill %s)\n", FMT_IU( GetViaDrill() ).c_str() );

    aFormatter->Print( aNestLevel+1, "(uvia_dia %s)\n", FMT_IU( GetuViaDiameter() ).c_str() );
    aFormatter->Print( aNestLevel+1, "(uvia_drill %s)\n", FMT_IU( GetuViaDrill() ).c_str() );

    // Save the diff_pair_gap and diff_pair_width values only if not the default, to avoid unnecessary
    // incompatibility  with previous Pcbnew versions.
    if( ( DEFAULT_DIFF_PAIR_WIDTH != GetDiffPairWidth() ) ||
        ( DEFAULT_DIFF_PAIR_GAP != GetDiffPairGap() ) )
    {
        aFormatter->Print( aNestLevel+1, "(diff_pair_gap %s)\n", FMT_IU( GetDiffPairGap() ).c_str() );
        aFormatter->Print( aNestLevel+1, "(diff_pair_width %s)\n", FMT_IU( GetDiffPairWidth() ).c_str() );
    }

    // Save constraint data only if set, to avoid unnecessary incompatibility with previous Pcbnew versions.
    if( DEFAULT_MAX_VIAS != GetMaxVias() )
    {
        aFormatter->Print( aNestLevel+1, "(max_vias %s)\n", FMT_IU( GetMaxVias() ).c_str() );
    }
    if( DEFAULT_TOPOLOGY != GetTopology() )
    {
        aFormatter->Print( aNestLevel+1, "(topology %s)\n", FMT_IU( GetTopology() ).c_str() );
    }
    if( DEFAULT_MIN_LENGTH != GetMinLength() )
    {
        aFormatter->Print( aNestLevel+1, "(min_length %s)\n", FMT_IU( GetMinLength() ).c_str() );
    }
    if( DEFAULT_MAX_LENGTH != GetMaxLength() )
    {
        aFormatter->Print( aNestLevel+1, "(max_length %s)\n", FMT_IU( GetMaxLength() ).c_str() );
    }
    if( DEFAULT_MAX_SKEW != GetMaxSkew() )
    {
        aFormatter->Print( aNestLevel+1, "(max_skew %s)\n", FMT_IU( GetMaxSkew() ).c_str() );
    }
    if( DEFAULT_STUB_LENGTH != GetStubLength() )
    {
        aFormatter->Print( aNestLevel+1, "(stub_length %s)\n", FMT_IU( GetStubLength() ).c_str() );
    }
    if( DEFAULT_TYPE != GetType() )
    {
        aFormatter->Print( aNestLevel+1, "(type %s)\n", FMT_IU( GetType() ).c_str() );
    }
    if( DEFAULT_LAYER != GetLayer() )
    {
        aFormatter->Print( aNestLevel+1, "(bind_layer %s)\n", FMT_IU( GetLayer() ).c_str() );
    }


    for( NETCLASS::const_iterator it = begin(); it != end(); ++it )
        aFormatter->Print( aNestLevel+1, "(add_net %s)\n", aFormatter->Quotew( *it ).c_str() );

    aFormatter->Print( aNestLevel, ")\n\n" );
}
